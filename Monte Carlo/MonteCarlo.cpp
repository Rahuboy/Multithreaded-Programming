// Code by Rahul Ramachandran
// For simplicity (and without loss of generality) we assume that the circle has radius 1, and is centred at the origin. 
#include <iostream>
#include <pthread.h>
#include <fstream>
#include <sys/time.h>
#include <vector>
#include <cstdlib>
#include <unistd.h>
#include <random>
#include <utility>
#include <tuple>

using namespace std;
typedef long long ll;


vector<ll> points_inside_circle; //Global vector which stores the number of points inside the circle for each thread
vector<ll> divided_npoints; //Global vector which contains the number of points to be generated for each thread. (Also equal to number of points inside square for each thread)
vector<ll> indices; //Global vector used to index the threads
vector< vector < pair <float, float> > > coordinates; //Vector that contains all the coordinates to be outputted
vector< vector<int> > flag_inside_circle; //Vector that contains a vector for each thread, which in turn contains 1s (if the coordinate is inside the circle) and 0s (if not)

//The function run by each thread
void* MonteCarlo(void* index)
{
    //Using a mersenne random number generator to generate random numbers
    random_device seedgen; //generates the seed
    mt19937 rng(seedgen()); //seeded mersenne rng
    uniform_real_distribution<> dist(-1.0, 1.0);
    
    int* ind = (int*)index; //ind is a pointer to the integer index for the thread
    ll npoints_inside_circle = 0; //Variable keeps track of number of points inside circle
    vector< pair<float, float> > thread_coordinates; //Vector containing the coordinates of the points generated by this thread
    vector<int> thread_flag_inside_circle; //Vector of flags to indicate whether the corresponding points are in the circle or not



    for(ll i = 0; i < divided_npoints[*ind]; i++)
    {
        float x = dist(rng); //Randomly generate x coordinate
        float y = dist(rng); //Randomly generate y coordinate

        if(x*x + y*y < 1) //Check if point lies in circle
        {
            npoints_inside_circle++; //Points on the boundary are not considered to lie inside the circle
            thread_flag_inside_circle.push_back(1); //Set flag to one

        }
        else thread_flag_inside_circle.push_back(0); //Set flag to zero

        pair<float, float> random_coordinates = make_pair(x,y);
        thread_coordinates.push_back(random_coordinates);
    }

    points_inside_circle[*ind] = npoints_inside_circle; //Set the value of the global vector for the corresponding index (using the thread number)
    coordinates[*ind] = thread_coordinates; //Set the coordinate vector (global) for the corresponding index (using the thread number)
    flag_inside_circle[*ind] = thread_flag_inside_circle; 

    pthread_exit(0);
}


int main()
{
    struct timeval tv1, tv2;
    gettimeofday(&tv1, NULL); //Function used to compute time

    ifstream input_file; //Open input file
    input_file.open("inp.txt");

    ll npoints, nthreads;

    if(input_file.is_open())
    {
        input_file >> npoints >> nthreads; //Read number of points and threads from input file
    }

    pthread_t threads[nthreads]; //Create 'nthreads' threads

    for(ll i = 0; i < nthreads; i++)
    {
        indices.push_back(i); //Set the thread numbers by pushing to global vector (0-indexed) 
    }

    //Resize the global vectors so that they can be index accessed later
    points_inside_circle.resize(nthreads); 
    divided_npoints.resize(nthreads);
    coordinates.resize(nthreads);
    flag_inside_circle.resize(nthreads);

    ll remainder = npoints - (npoints/nthreads)*nthreads; //The variable remainder is used to divide the no. of random numbers as equitably as possible. 

    for(ll i = 0; i < nthreads; i++)
    {
        //Divide the numbers between the threads
        if(remainder > 0)
        {
            divided_npoints[i] = (npoints/nthreads) + 1;
            remainder--;
        }
        else  divided_npoints[i] = (npoints/nthreads);
    }

    //Create the threads
    for(ll i = 0; i < nthreads; i++) pthread_create(&threads[i], NULL, &MonteCarlo, (void *)&indices[i]);
    //Wait for the threads to stop executing
    for(ll i = 0; i < nthreads; i++) pthread_join(threads[i], NULL);

    ll tot_npoint_inside_circle = 0; //Variable for finding total number of points inside circle
    for(ll i = 0; i < nthreads; i++) tot_npoint_inside_circle += points_inside_circle[i]; //Compute total number of points inside circle

    float computed_pi = 4 * (float)tot_npoint_inside_circle/npoints; //Compute pi by dividing the total number of points inside circle with the total number of points, and multiplying by 4 (Monte Carlo formula)

    //Stop the clock after pi is computed
    gettimeofday(&tv2, NULL);
    float time_elapsed = (double)(tv2.tv_usec - tv1.tv_usec)/1000000 + (double)(tv2.tv_sec - tv1.tv_sec);

    // cout << "Finished computing time\n" << time_elapsed * 1e6 << " " << computed_pi; //Extra code for checking

    // Create (or write to) output file
    ofstream output_file;
    output_file.open("output.txt");
    if(output_file.is_open())
    {
        output_file << "Time: " << time_elapsed * 1e6 << "\u03BC" << "s\n\n"; //Writing time
        output_file << "Value Computed: " << computed_pi << "\n\n"; //Writing value of pi computed
        output_file << "Log:\n\n"; 
        for(int i = 0; i < nthreads; i++)
        {
            output_file << "Thread" << i+1 << ": " << divided_npoints[i] << ", " << points_inside_circle[i] << "\n" ;
            vector< pair <float, float> > thread_coordinates = coordinates[i];
            vector<int> thread_flag_inside_circle = flag_inside_circle[i];
            output_file << "Points inside the square: "; //Writing all the coordinates inside the square for the thread
            for(int j = 0; j < thread_coordinates.size(); j++)
            {
                output_file << "(" << thread_coordinates[j].first << "," << thread_coordinates[j].second <<"), "; 
            }
            output_file << "\nPoints inside the circle: "; //Writing all the coordinates inside the circle for the thread
            for(int j = 0; j < thread_coordinates.size(); j++)
            {
                if(thread_flag_inside_circle[j] == 1)
                {
                    output_file << "(" << thread_coordinates[j].first << "," << thread_coordinates[j].second <<"), "; 
                }
            }
            output_file << "\n\n";
        }
    }

}





















